好的，我先详细说明一下智能合约的设计思路和实现策略，不写代码。

## 智能合约设计思路 / Smart Contract Design Approach

### 1. 合约架构设计 / Contract Architecture Design

**合约名称**: `ParaGoalBetting`
**设计原则**: 
- 模块化设计，功能清晰分离
- 安全第一，防止常见攻击（重入、溢出等）
- Gas优化，减少不必要的存储操作
- 可扩展性，便于后续功能迭代

### 2. 核心数据结构设计 / Core Data Structure Design

**比赛管理结构 / Match Management Structure:**
- 使用 `struct Match` 存储每场比赛的完整信息
- 采用 `mapping(uint256 => Match)` 以比赛ID为键快速查找
- 内置比赛和用户创建比赛统一管理，通过 `isBuiltIn` 字段区分

**投注记录结构 / Stake Record Structure:**
- 使用 `mapping(uint256 => mapping(address => Stake))` 二维映射
- 支持一个用户在同一场比赛中多次投注同一队伍（累加金额）
- 记录投注状态和领取状态，防止重复领取

**奖池管理 / Pool Management:**
- 实时计算和存储每个队伍的投注总额
- 支持多次注入奖池，累加到总奖池
- 记录首次注入者作为平台手续费接收方

### 3. 状态机设计 / State Machine Design

**比赛状态流转 / Match Status Flow:**
```
Pending → Open → Closed → Settled
```

- **Pending**: 比赛创建，等待开启投注
- **Open**: 开放投注，用户可以投注
- **Closed**: 关闭投注，等待管理员结算
- **Settled**: 已结算，用户可以领取奖金

**严格的状态控制**:
- 只有管理员可以关闭比赛（Pending → Open → Closed）
- 只有管理员可以结算比赛（Closed → Settled）
- 状态转换不可逆，确保数据一致性

### 4. 投注和结算算法 / Betting and Settlement Algorithm

**投注机制 / Betting Mechanism:**
- 用户发送PAS代币到合约地址进行投注
- 支持选择TeamA（0）或TeamB（1）
- 实时更新队伍投注总额和用户个人投注记录

**结算算法 / Settlement Algorithm:**
基于文档中的分配规则：
- **赢家方向**: 本金 + 70% × (个人投注比例 × 奖池总额) - 5%手续费
- **输家方向**: 本金 + 30% × (个人投注比例 × 奖池总额) - 5%手续费
- **平台手续费**: 所有扣除的5%手续费归集给首次注入奖池的地址

**数学公式实现**:
```solidity
// 用户投注比例 / User stake ratio
uint256 userRatio = userStake / totalStakeForTeam;

// 赢家分配 / Winner allocation
uint256 winnerShare = stakeAmount + (userRatio * poolAmount * 70) / 100;

// 输家分配 / Loser allocation  
uint256 loserShare = stakeAmount + (userRatio * poolAmount * 30) / 100;

// 扣除手续费 / Deduct fees
uint256 finalPayout = (winnerShare * 95) / 100; // 或 loserShare
```

### 5. 安全机制设计 / Security Mechanism Design

**权限控制 / Access Control:**
- 使用 `modifier onlyAdmin(uint256 matchId)` 确保只有比赛管理员可以执行关键操作
- 内置比赛的admin可以是零地址或系统地址
- 用户创建的比赛，创建者自动成为admin

**重入攻击防护 / Reentrancy Protection:**
- 在 `claimPayout()` 函数使用 `nonReentrant` 修饰符
- 采用"先更新状态，后转账"的模式（Checks-Effects-Interactions）

**精度和溢出保护 / Precision and Overflow Protection:**
- 使用 `SafeMath` 库进行数学运算
- 乘法在前，除法在后，避免精度丢失
- 使用18位精度处理小数计算

**边界条件检查 / Boundary Condition Checks:**
- 投注金额必须大于0
- 比赛必须处于Open状态才能投注
- 比赛必须处于Settled状态才能领取
- 防止对已结算的比赛进行重复操作

### 6. 事件设计 / Event Design

**关键事件 / Key Events:**
- `MatchCreated`: 比赛创建事件，记录比赛基本信息
- `PoolInjected`: 奖池注入事件，记录注入金额和接收方
- `Staked`: 用户投注事件，记录投注详情
- `MatchSettled`: 比赛结算事件，记录最终结果
- `PayoutClaimed`: 奖金领取事件，记录领取金额

**事件作用 / Event Purpose:**
- 前端监听事件，实时更新UI状态
- 便于调试和审计合约操作
- 支持链下数据分析

### 7. 测试页面集成策略 / Test Page Integration Strategy

**针对评审要求的设计 / Design for Judge Requirements:**

1. **钱包连接状态显示**:
   - 检测当前连接的Paseo网络
   - 显示用户钱包地址
   - 验证网络链ID是否为1111

2. **合约地址和区块浏览器**:
   - 显示部署的合约地址
   - 链接到Subscan浏览器查看合约详情
   - 提供合约ABI验证链接

3. **核心写入函数测试**:
   - 主要测试函数：`injectPool()` - 注入奖池
   - 备选测试函数：`createMatch()` - 创建比赛
   - 提供测试币金额输入框

4. **读取结果显示**:
   - 调用 `getMatch()` 显示比赛信息
   - 显示当前奖池总额
   - 显示合约总余额

5. **交易哈希追踪**:
   - 实时显示交易哈希
   - 链接到区块浏览器查看交易详情
   - 显示交易状态（pending/confirmed）

### 8. Gas优化策略 / Gas Optimization Strategy

**存储优化 / Storage Optimization:**
- 使用 `packed` 结构体减少存储槽使用
- 合理使用 `uint8` 和 `bool` 类型
- 避免不必要的状态变量

**函数优化 / Function Optimization:**
- 批量操作减少外部调用
- 使用 `view` 函数进行只读查询
- 合理设计函数参数，避免数组操作

### 9. 部署和测试策略 / Deployment and Testing Strategy

**部署环境 / Deployment Environment:**
- 目标网络：Polkadot Paseo Asset Hub测试网
- RPC端点：使用官方提供的WebSocket连接
- 测试币：从水龙头获取PAS代币

**测试计划 / Testing Plan:**
1. 单元测试：每个函数的基本功能
2. 集成测试：完整的用户流程
3. 边界测试：极端情况和错误处理
4. Gas测试：优化Gas消耗

**部署后配置 / Post-deployment Configuration:**
- 初始化4场内置比赛
- 配置合约地址到前端
- 更新ABI和网络配置
- 验证所有功能正常工作

